### 1接口和抽象类的区别

1 语法上的区别

 ①抽象类可以有普通成员变量和成员方法，接口只能有常量和抽象方法

2 设计上的区别

 抽象类是一类事物的抽象，抽取共同的行为和属性，是模板设计，接口是行为抽象， 是行为的规范设计。

### IOC

IOC是控制反转,我们不需要手工创建对象，只需要在xml或者用直接描述创建对象的类信息，IOC就会自动解析并存入beanDefinitionMap，IOC在beanFactory完成初始化时会把单例的bean注册到singleTonObejcts容器中

IOC的好处

1 bean生命周期的管理，例如实现DisposableBean接口可以在调用destroy()前后做一些资源的释放

2 BeanPostProcessor实现该接口在bean实例化前后实现自己的业务逻辑

### AOP

aop面向切面编程，以动态代理为技术基础，将分散在各个模块相同逻辑的代码通过横向切割的方式抽取到独立的模块中，达到解耦和简练代码的作用

切面:

由切点和增强组成，包括横切逻辑的定义和连接点的定义

切点:

具体定位的连接点就是切点

连接点：

能够被拦截的方法都是连接点

织入:

把增强的业务代码添加到具体的目标连接点上的过程

增强:

对目标方法执行前后进行拦截执行特定逻辑的业务代码



### eureka

eureka是AP原则



### bean生命周期

- Spring容器 从XML 文件中读取bean的定义，并实例化bean。
- Spring根据bean的定义填充所有的属性。
- 如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。
- 如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。
- 如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。
- 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。
- 如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。
- 如果bean实现了 DisposableBean，它将调用destroy()方法





## 问题清单

### 1高可用，集群

redis和mysql,包括读写分离，数据备份

redis备份快照和另外一种方式

int的栈上分配

int、long等占多少位？

2的一百次方简单高效的做法

方法逃逸和线程逃逸

双亲委派模型是否可以父子加载器是否可以互相加载

锁的深度应用

自旋锁、偏向锁、轻量级锁

CopyWriteArrayList

spring ioc和aop，声明式事务和事务的传播属性(DataSourceTransactionManager)

BigDecimal高精度的实现原理

xss攻击和sql注入

springIOC和AOP

AOP实现事务

spring 依赖注入的方式

分布式锁

exists

InnoDB特性，MyISAM

session共享

redis序列化

大数据导入(申请内存和多线程)

分布式锁和分布式事务

线程虚假唤醒

数据库事务

接口被截包了，---数字签名和加密

jdk8 stream删除

生产消费者模式

